package com.oldguy.database

abstract class PreparedStatement(val sql: String) {
    var bindArguments: SqlValues = SqlValues()
        internal set
    var isOpen = false
        internal set
    var isBound = false
        internal set
    abstract val parameterCount: Int

    open val isReadOnly: Boolean = false

    /**
     * Convenience wrapper to perform any number of operations on the statement, then close the
     * statement when done
     */
    suspend fun use(block: suspend (stmt: PreparedStatement) -> Unit) {
        block(this)
        close()
    }

    /**
     * Execute an sql statement once, after any supplied bind variables are applied
     * @return number of rows affected by execute, or -1 if some error
     */
    abstract fun execute(bindParameters: SqlValues = SqlValues()): Int

    /**
     * Use this for insert SQL into a table containing a ROWID, where Sqlite is generating the ROWID.
     * After the insert, the ROWID generated by the insert is returned.  Without this, after calling the
     * standard [execute] function, the ROWID must be retrieved using some other function immediately after.
     *
     * @param bindArguments contains zero or more SqlValue objects.  If each object is named, all must be named,
     * and all names must be unique.  @see SqlValue for details on null support, formatting etc. If names are used
     * and bindArguments has any values whose names do not match a variable in the SQL, an Exception is thrown,
     * If none of the values have names, then bind by index is used.  If the values supplied are more than the
     * bind variables in the SQL, an exception is thrown.
     * In either mode (named or indexed), variables in the SQL that do not have matches in the bind arguments
     * are treated as if they were bound to null.
     * @return the ROWID used in this insert. -1 is returned if this is mistakenly used on a table that does
     * not have a ROWID.
     */
    abstract fun insert(bindArguments: SqlValues = SqlValues()): Long

    open fun close() {
        isOpen = false
        isBound = false
    }
}

abstract class Query(selectSql:String): PreparedStatement(selectSql) {

    val columns = Columns()
    override val isReadOnly = true
    abstract val columnCount: Int

    /**
     * If populated, the number of values must match columnCount before attempting retrieve.
     * Contents of this row will specify the concrete RowValue type to be returned for each
     * column.  Use this to override the default column type to value type translation made at
     * query time.
     */
    val targetTypes = SqlValues()

    override fun execute(bindParameters: SqlValues): Int {
        throw IllegalStateException("Cannot execute query, use retrieve operations")
    }

    abstract fun retrieveList(bindParameters: SqlValues = SqlValues()): List<SqlValues>

    abstract suspend fun retrieve(
        bindParameters: SqlValues = SqlValues(),
        oneRow: suspend (rowCount: Int, SqlValues) -> Boolean
    ): Int

    abstract suspend fun retrieveOne(
        bindParameters: SqlValues = SqlValues(),
        oneRow: suspend (rowCount: Int, SqlValues) -> Unit
    ): Int

    /**
     * Iterate one row resulting from select SQL.
     * @return SqlValues will be empty if no rows remain. Otherwise will contain one of the SqlValue
     * sealed class types for each column, appropriate to the column type, each with the value from
     * the row. The SqlValue type can either be left to default, or can be dictated by setting the
     * targetTypes property of the query with your own. If targetTypes is present, the number of them
     * provided must match the column count of the select, or an exception is thrown.
     */
    abstract fun nextRow(): SqlValues
}