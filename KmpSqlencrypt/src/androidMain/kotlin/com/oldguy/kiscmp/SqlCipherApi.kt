package com.oldguy.kiscmp

actual class SqliteDatabase {
    internal val shim = Sqlite3JniShim()
    actual var encoding = SqliteEncoding.Utf_8
    actual val notDatabaseResult = 26 // must match SQLITE_NOTADB value

    actual fun error(): String {
        return shim.error()
    }

    actual fun fileName(): String {
        return shim.fileName()
    }

    actual fun open(
        path: String,
        readOnly: Boolean,
        createOk: Boolean
    ): Int {
        return shim.open(path, readOnly, createOk)
    }

    actual fun close(): Int {
        return shim.close()
    }

    actual fun softHeapLimit(limit: Long): Long {
        return shim.softHeapLimit(limit)
    }

    actual fun busyTimeout(timeout: Int) {
        return shim.busyTimeout((timeout))
    }

    actual fun exec(
        sql: String,
        callback: ((values: Array<String>, columnNames: Array<String>) -> Int)?
    ): Int {
        return callback?.let {
            shim.exec(sql, it)
        } ?: shim.exec(sql)
    }

    actual fun exec(sql: String): Int {
        return shim.exec(sql)
    }

    actual fun version(): String {
        return shim.version()
    }

    /**
     * Useful after an Insert statement when a ROWID is expected to be generated by Sqlite during
     * the insert
     */
    actual fun lastInsertRowid(): Long {
        return shim.lastInsertRowid()
    }

    actual fun sleep(millis: Int) {
        shim.sleep(millis)
    }
}

actual class SqliteStatement actual constructor(val db: SqliteDatabase) {
    private val shim = Sqlite3StatementJniShim()

    actual fun parameterCount(): Int {
        return shim.parameterCount()
    }

    actual fun isReadOnly(): Boolean {
        return shim.isReadOnly()
    }

    actual fun prepare(sql: String): Int {
        return shim.prepare(db.shim.handle, sql)
    }

    actual fun bindIndex(name: String): Int {
        return shim.bindIndex(name)
    }

    actual fun bindNull(index: Int): Int {
        return shim.bindNull(index)
    }

    actual fun bindText(index: Int, text: String): Int {
        return shim.bindText(index, text)
    }

    actual fun bindInt(index: Int, value: Int): Int {
        return shim.bindInt(index, value)
    }

    actual fun bindLong(index: Int, value: Long): Int {
        return shim.bindLong(index, value)
    }

    actual fun bindDouble(index: Int, value: Double): Int {
        return shim.bindDouble(index, value)
    }

    actual fun bindBytes(index: Int, array: ByteArray): Int {
        return shim.bindBytes(index, array)
    }

    actual fun step(): SqliteStepResult {
        val rc = shim.stepInt()
        return when (rc) {
            1 -> SqliteStepResult.Error
            2 -> SqliteStepResult.Done
            3 -> SqliteStepResult.Row
            4 -> SqliteStepResult.Busy
            else -> throw SqliteException("Unsupported return from StepInt(): $rc")
        }
    }

    actual fun changes(): Int {
        return shim.changes(db.shim.handle)
    }

    actual fun finalize(): Int {
        return shim.finalize()
    }

    actual fun clearBindings() {
        shim.clearBindings()
    }

    actual fun reset() {
        shim.reset()
    }

    /**
     * The following functions are only useful when preparing and running a select statement.
     */
    actual fun expandedSql(): String {
        return shim.expandedSql()
    }

    actual fun isBusy(): Boolean {
        return shim.isBusy()
    }

    actual fun columnCount(): Int {
        return shim.columnCount()
    }

    actual fun dataCount(): Int {
        return shim.dataCount()
    }

    actual fun columnName(index: Int): String {
        return shim.columnName(index)
    }

    actual fun columnDeclaredType(index: Int): String {
        return shim.columnDeclaredType(index)
    }

    actual fun columnType(index: Int): SqliteColumnType {
        val rc = shim.columnTypeInt(index)
        return when (rc) {
            1 -> SqliteColumnType.Null
            2 -> SqliteColumnType.Text
            3 -> SqliteColumnType.Integer
            4 -> SqliteColumnType.Float
            5 -> SqliteColumnType.Blob
            else -> throw SqliteException("Unsupported return from columnTypeInt($index): $rc")
        }
    }

    actual fun columnText(index: Int): String {
        return shim.columnText(index)
    }

    actual fun columnBlob(index: Int): ByteArray {
        return shim.columnBlob(index)
    }

    actual fun columnDouble(index: Int): Double {
        return shim.columnDouble(index)
    }

    actual fun columnInt(index: Int): Int {
        return shim.columnInt(index)
    }

    actual fun columnLong(index: Int): Long {
        return shim.columnLong(index)
    }
}